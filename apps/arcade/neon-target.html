<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Neon Target - Arcade Game</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Neon Target Game Specific Styles */
        .neon-target-container {
            text-align: center;
            padding: 1rem;
            background: var(--dark-bg);
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .neon-target-header {
            margin-bottom: 1rem;
            position: relative;
            z-index: 10;
        }

        .neon-target-title {
            color: var(--neon-pink);
            text-shadow: 0 0 20px var(--neon-pink);
            font-size: 2rem;
            margin-bottom: 0.5rem;
            animation: neonGlow 2s ease-in-out infinite alternate;
        }

        .neon-target-score {
            color: var(--neon-blue);
            font-size: 1rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .neon-target-lives {
            color: var(--neon-green);
            font-size: 0.8rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--neon-green);
        }

        .neon-target-level {
            color: var(--neon-yellow);
            font-size: 0.8rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--neon-yellow);
        }

        #neonTargetCanvas {
            border: 4px solid var(--neon-purple);
            border-radius: 15px;
            background: linear-gradient(45deg, #0a0a0a, #1a0a2e);
            box-shadow: 
                0 0 30px var(--neon-purple),
                inset 0 0 30px rgba(131, 56, 236, 0.2);
            margin: 1rem auto;
            display: block;
            cursor: crosshair;
            position: relative;
            z-index: 5;
        }

        .neon-target-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
            position: relative;
            z-index: 10;
        }

        .control-row {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .neon-target-btn {
            width: 80px;
            height: 50px;
            background: var(--neon-purple);
            color: white;
            border: 3px solid var(--neon-blue);
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--neon-purple);
            text-align: center;
            line-height: 1.2;
        }

        .neon-target-btn:hover {
            background: var(--neon-pink);
            box-shadow: 0 0 25px var(--neon-pink);
            transform: scale(1.05);
        }

        .neon-target-btn:active {
            transform: scale(0.95);
        }

        .start-btn {
            width: 150px;
            height: 60px;
            font-size: 0.7rem;
            background: var(--neon-green);
            color: #000;
            border-color: var(--neon-green);
            box-shadow: 0 0 20px var(--neon-green);
        }

        .start-btn:hover {
            background: var(--neon-yellow);
            box-shadow: 0 0 30px var(--neon-yellow);
        }

        .pause-btn {
            background: var(--neon-yellow);
            color: #000;
            border-color: var(--neon-yellow);
        }

        .pause-btn:hover {
            background: var(--neon-pink);
            box-shadow: 0 0 25px var(--neon-pink);
        }

        .neon-target-instructions {
            margin-top: 1rem;
            color: var(--neon-blue);
            font-size: 0.6rem;
            line-height: 1.6;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .neon-target-instructions p {
            margin: 0.5rem 0;
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid var(--neon-pink);
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 50px var(--neon-pink);
        }

        .game-over-title {
            color: var(--neon-pink);
            font-size: 1.5rem;
            text-shadow: 0 0 20px var(--neon-pink);
            margin-bottom: 1rem;
        }

        .final-score {
            color: var(--neon-green);
            font-size: 1rem;
            text-shadow: 0 0 10px var(--neon-green);
            margin-bottom: 1rem;
        }

        .high-score {
            color: var(--neon-yellow);
            font-size: 0.8rem;
            text-shadow: 0 0 10px var(--neon-yellow);
            margin-bottom: 1rem;
        }

        .restart-btn {
            width: 120px;
            height: 50px;
            font-size: 0.6rem;
            background: var(--neon-purple);
            color: white;
            border: 3px solid var(--neon-blue);
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--neon-purple);
        }

        .restart-btn:hover {
            background: var(--neon-pink);
            box-shadow: 0 0 25px var(--neon-pink);
            transform: scale(1.05);
        }

        .back-to-arcade {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--neon-purple);
            color: white;
            border: 2px solid var(--neon-blue);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 15px var(--neon-purple);
            text-decoration: none;
            display: inline-block;
        }

        .back-to-arcade:hover {
            background: var(--neon-pink);
            box-shadow: 0 0 25px var(--neon-pink);
            transform: scale(1.05);
        }

        /* Animated background particles */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--neon-pink);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFloat 4s linear infinite;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(100vh) scale(0);
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) scale(1);
            }
            90% {
                opacity: 0.5;
                transform: translateY(10vh) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(0) scale(0);
            }
        }

        /* Target hit effect */
        .target-hit {
            animation: targetHit 0.3s ease-out;
        }

        @keyframes targetHit {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(0); }
        }

        /* Power-up effects */
        .power-up-active {
            animation: powerUpGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes powerUpGlow {
            from { 
                box-shadow: 0 0 20px var(--neon-green);
                border-color: var(--neon-green);
            }
            to { 
                box-shadow: 0 0 40px var(--neon-green), 0 0 60px var(--neon-yellow);
                border-color: var(--neon-yellow);
            }
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .neon-target-title {
                font-size: 1.2rem;
            }
            
            #neonTargetCanvas {
                width: 300px;
                height: 400px;
            }
            
            .neon-target-btn {
                width: 60px;
                height: 40px;
                font-size: 0.5rem;
            }
            
            .start-btn {
                width: 120px;
                height: 50px;
                font-size: 0.6rem;
            }
            
            .neon-target-instructions {
                font-size: 0.5rem;
                padding: 0 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="grid-background"></div>
    
    <div class="neon-target-container">
        <a href="index.html" class="back-to-arcade">‚Üê BACK TO ARCADE</a>
        
        <div class="neon-target-header">
            <h1 class="neon-target-title">üéØ NEON TARGET üéØ</h1>
            <div class="neon-target-score">SCORE: <span id="score">0</span></div>
            <div class="neon-target-lives">LIVES: <span id="lives">3</span></div>
            <div class="neon-target-level">LEVEL: <span id="level">1</span></div>
        </div>

        <canvas id="neonTargetCanvas" width="500" height="600"></canvas>

        <div class="neon-target-controls">
            <div class="control-row">
                <button class="neon-target-btn start-btn" id="startBtn">START GAME</button>
                <button class="neon-target-btn pause-btn" id="pauseBtn" disabled>PAUSE</button>
            </div>
            <div class="control-row">
                <button class="neon-target-btn" id="restartBtn">RESTART</button>
                <button class="neon-target-btn" id="muteBtn">MUTE</button>
            </div>
        </div>

        <div class="neon-target-instructions">
            <p><strong>üéØ HOW TO PLAY:</strong></p>
            <p>‚Ä¢ Click on the neon targets to score points</p>
            <p>‚Ä¢ Different targets have different point values</p>
            <p>‚Ä¢ Don't let targets escape or you'll lose a life</p>
            <p>‚Ä¢ Collect power-ups for special abilities</p>
            <p>‚Ä¢ Survive as long as possible to reach high scores!</p>
            <p><strong>üéÆ CONTROLS:</strong></p>
            <p>‚Ä¢ Mouse: Aim and click to shoot</p>
            <p>‚Ä¢ Spacebar: Quick shoot</p>
            <p>‚Ä¢ P: Pause/Resume game</p>
            <p>‚Ä¢ R: Restart game</p>
        </div>

        <div class="game-over-screen" id="gameOverScreen" style="display: none;">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score">FINAL SCORE: <span id="finalScore">0</span></div>
            <div class="high-score">HIGH SCORE: <span id="highScore">0</span></div>
            <button class="restart-btn" id="restartGameBtn">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            isRunning: false,
            isPaused: false,
            score: 0,
            lives: 3,
            level: 1,
            highScore: 0,
            targets: [],
            powerUps: [],
            particles: [],
            lastTargetSpawn: 0,
            targetSpawnRate: 2000, // milliseconds
            gameSpeed: 1,
            isMuted: false
        };

        // Canvas setup
        const canvas = document.getElementById('neonTargetCanvas');
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();

        // Load high score from localStorage
        gameState.highScore = parseInt(localStorage.getItem('neonTargetHighScore')) || 0;
        document.getElementById('highScore').textContent = gameState.highScore;

        // Target class
        class Target {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.radius = type === 'small' ? 15 : type === 'large' ? 35 : 25;
                this.type = type;
                this.speed = type === 'small' ? 2 : type === 'large' ? 0.5 : 1;
                this.direction = Math.random() * Math.PI * 2;
                this.life = type === 'small' ? 1 : type === 'large' ? 3 : 2;
                this.maxLife = this.life;
                this.points = type === 'small' ? 50 : type === 'large' ? 20 : 30;
                this.color = this.getColor();
                this.hit = false;
                this.hitTime = 0;
                this.pulsePhase = 0;
            }

            getColor() {
                const colors = [
                    'var(--neon-pink)',
                    'var(--neon-blue)', 
                    'var(--neon-green)',
                    'var(--neon-yellow)',
                    'var(--neon-purple)'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                if (this.hit) {
                    this.hitTime++;
                    if (this.hitTime > 10) {
                        return false; // Remove target
                    }
                    return true;
                }

                this.pulsePhase += 0.1;
                this.x += Math.cos(this.direction) * this.speed * gameState.gameSpeed;
                this.y += Math.sin(this.direction) * this.speed * gameState.gameSpeed;

                // Bounce off edges
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.direction = Math.PI - this.direction;
                }
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.direction = -this.direction;
                }

                // Keep target in bounds
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                return true;
            }

            draw() {
                if (this.hit) {
                    // Draw explosion effect
                    const alpha = 1 - (this.hitTime / 10);
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = 'var(--neon-yellow)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                ctx.save();
                
                // Pulsing effect
                const pulse = 1 + Math.sin(this.pulsePhase) * 0.1;
                const currentRadius = this.radius * pulse;

                // Outer glow
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Inner circle
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Life indicator
                if (this.life < this.maxLife) {
                    ctx.fillStyle = 'var(--neon-red)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRadius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Points text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.points.toString(), this.x, this.y + 4);

                ctx.restore();
            }

            isHit(mouseX, mouseY) {
                const distance = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                return distance <= this.radius;
            }

            takeDamage() {
                this.life--;
                if (this.life <= 0) {
                    this.hit = true;
                    return true; // Target destroyed
                }
                return false; // Target still alive
            }
        }

        // Power-up class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.type = type;
                this.speed = 1;
                this.direction = Math.random() * Math.PI * 2;
                this.life = 300; // frames
                this.pulsePhase = 0;
                this.color = this.getColor();
            }

            getColor() {
                switch(this.type) {
                    case 'multiplier': return 'var(--neon-yellow)';
                    case 'slow': return 'var(--neon-blue)';
                    case 'rapid': return 'var(--neon-green)';
                    case 'life': return 'var(--neon-pink)';
                    default: return 'var(--neon-purple)';
                }
            }

            update() {
                this.pulsePhase += 0.15;
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;
                this.life--;

                // Bounce off edges
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.direction = Math.PI - this.direction;
                }
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.direction = -this.direction;
                }

                return this.life > 0;
            }

            draw() {
                ctx.save();
                
                const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
                const currentRadius = this.radius * pulse;

                // Outer glow
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Inner symbol
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.getSymbol(), this.x, this.y + 5);

                ctx.restore();
            }

            getSymbol() {
                switch(this.type) {
                    case 'multiplier': return '√ó';
                    case 'slow': return '‚è±';
                    case 'rapid': return '‚ö°';
                    case 'life': return '‚ù§';
                    default: return '?';
                }
            }

            isHit(mouseX, mouseY) {
                const distance = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                return distance <= this.radius;
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Game functions
        function spawnTarget() {
            const types = ['normal', 'small', 'large'];
            const type = types[Math.floor(Math.random() * types.length)];
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = Math.random() * (canvas.height - 100) + 50;
            
            gameState.targets.push(new Target(x, y, type));
        }

        function spawnPowerUp() {
            if (Math.random() < 0.1) { // 10% chance
                const types = ['multiplier', 'slow', 'rapid', 'life'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                
                gameState.powerUps.push(new PowerUp(x, y, type));
            }
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push(new Particle(x, y, color));
            }
        }

        function updateGame() {
            if (!gameState.isRunning || gameState.isPaused) return;

            // Spawn targets
            const now = Date.now();
            if (now - gameState.lastTargetSpawn > gameState.targetSpawnRate) {
                spawnTarget();
                gameState.lastTargetSpawn = now;
            }

            // Spawn power-ups
            spawnPowerUp();

            // Update targets
            gameState.targets = gameState.targets.filter(target => {
                const alive = target.update();
                if (!alive && !target.hit) {
                    // Target escaped
                    gameState.lives--;
                    updateUI();
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
                return alive;
            });

            // Update power-ups
            gameState.powerUps = gameState.powerUps.filter(powerUp => powerUp.update());

            // Update particles
            gameState.particles = gameState.particles.filter(particle => particle.update());

            // Level progression
            const newLevel = Math.floor(gameState.score / 1000) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                gameState.targetSpawnRate = Math.max(500, gameState.targetSpawnRate - 100);
                gameState.gameSpeed = Math.min(3, gameState.gameSpeed + 0.1);
                updateUI();
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid background
            ctx.strokeStyle = 'rgba(131, 56, 236, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw targets
            gameState.targets.forEach(target => target.draw());

            // Draw power-ups
            gameState.powerUps.forEach(powerUp => powerUp.draw());

            // Draw particles
            gameState.particles.forEach(particle => particle.draw());

            // Draw crosshair
            if (gameState.isRunning) {
                ctx.strokeStyle = 'var(--neon-green)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
                ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
                ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
                ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
                ctx.stroke();
            }
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.targets = [];
            gameState.powerUps = [];
            gameState.particles = [];
            gameState.targetSpawnRate = 2000;
            gameState.gameSpeed = 1;
            gameState.lastTargetSpawn = Date.now();

            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('gameOverScreen').style.display = 'none';

            updateUI();
            gameLoop();
        }

        function pauseGame() {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? 'RESUME' : 'PAUSE';
        }

        function gameOver() {
            gameState.isRunning = false;
            gameState.isPaused = false;

            // Update high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('neonTargetHighScore', gameState.highScore.toString());
            }

            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('highScore').textContent = gameState.highScore;
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'PAUSE';
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('level').textContent = gameState.level;
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            if (!gameState.isRunning || gameState.isPaused) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check target hits
            let hit = false;
            gameState.targets.forEach((target, index) => {
                if (target.isHit(mouseX, mouseY)) {
                    hit = true;
                    const destroyed = target.takeDamage();
                    if (destroyed) {
                        gameState.score += target.points * gameState.level;
                        createParticles(target.x, target.y, target.color, 15);
                        gameState.targets.splice(index, 1);
                    }
                }
            });

            // Check power-up hits
            gameState.powerUps.forEach((powerUp, index) => {
                if (powerUp.isHit(mouseX, mouseY)) {
                    hit = true;
                    applyPowerUp(powerUp.type);
                    createParticles(powerUp.x, powerUp.y, powerUp.color, 8);
                    gameState.powerUps.splice(index, 1);
                }
            });

            if (hit) {
                updateUI();
            }
        });

        function applyPowerUp(type) {
            switch(type) {
                case 'multiplier':
                    gameState.score *= 2;
                    break;
                case 'slow':
                    gameState.gameSpeed *= 0.5;
                    setTimeout(() => gameState.gameSpeed *= 2, 5000);
                    break;
                case 'rapid':
                    gameState.targetSpawnRate *= 0.5;
                    setTimeout(() => gameState.targetSpawnRate *= 2, 5000);
                    break;
                case 'life':
                    gameState.lives++;
                    break;
            }
        }

        // Button event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('pauseBtn').addEventListener('click', pauseGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            gameOver();
            setTimeout(startGame, 100);
        });
        document.getElementById('restartGameBtn').addEventListener('click', () => {
            gameOver();
            setTimeout(startGame, 100);
        });

        document.getElementById('muteBtn').addEventListener('click', () => {
            gameState.isMuted = !gameState.isMuted;
            document.getElementById('muteBtn').textContent = gameState.isMuted ? 'UNMUTE' : 'MUTE';
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    if (gameState.isRunning && !gameState.isPaused) {
                        // Quick shoot at center
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        
                        gameState.targets.forEach((target, index) => {
                            if (target.isHit(centerX, centerY)) {
                                const destroyed = target.takeDamage();
                                if (destroyed) {
                                    gameState.score += target.points * gameState.level;
                                    createParticles(target.x, target.y, target.color, 15);
                                    gameState.targets.splice(index, 1);
                                }
                            }
                        });
                        updateUI();
                    }
                    break;
                case 'p':
                    if (gameState.isRunning) {
                        pauseGame();
                    }
                    break;
                case 'r':
                    if (gameState.isRunning) {
                        gameOver();
                        setTimeout(startGame, 100);
                    }
                    break;
            }
        });

        // Initialize game
        updateUI();
        gameLoop();

        // Create background particles
        setInterval(() => {
            if (Math.random() < 0.3) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.background = ['var(--neon-pink)', 'var(--neon-blue)', 'var(--neon-green)', 'var(--neon-yellow)', 'var(--neon-purple)'][Math.floor(Math.random() * 5)];
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 4000);
            }
        }, 200);

        console.log('üéØ Neon Target game initialized!');
    </script>
</body>
</html>